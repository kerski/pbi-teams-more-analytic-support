trigger: none

variables:
  # Group containing environment variables for the pipeline
  - group: MYPBITMA-SP

resources:
  pipelines:
    # Reference to another pipeline that triggers this pipeline
    - pipeline: test-trigger
      source: PBIP-CI
      project: PBI-Test
      trigger:
        branches:
          include:
            - development

jobs:
- job: TriggeredBuild
  workspace:
      clean: all
  pool:
    vmImage: 'windows-latest' # Use the latest Windows image for the build agent

  steps:
  # Step 1: Checkout the current code with full Git history
  - checkout: self
    persistCredentials: true
    fetchDepth: 0

  # Step 2: Download the artifact named 'CombinedReports' from the triggering pipeline
  - task: DownloadBuildArtifacts@1
    inputs:
      buildType: 'specific'
      project: 'PBI-Test' # Replace with your project name
      pipeline: '$(UPSTREAM_PIPELINE_ID)' # ID of the pipeline that publishes the artifact
      runVersion: 'latest'
      artifactName: 'CombinedReports'
      targetPath: '$(Pipeline.Workspace)/CombinedReports'
      itemPattern: CombinedReports/**

  # Step 3: Process each *.Report folder and call PBI Inspector CLI
  - task: PowerShell@2
    inputs:
      pwsh: true
      targetType: 'inline'
      script: |
        # Load environment variables
        $certBase64 = ${env:CERT_BASE64}
        $certPassword = ${env:CERT_PASSWORD}
        $siteUrl = "${env:SITE_URL}"
        $libraryName = "${env:LIBRARY_NAME}"
        $tenantId = "${env:TENANT_ID}"
        $clientId = "${env:CLIENT_ID}"

        # Convert the certificate password to a secure string
        $securePassword = ConvertTo-SecureString -String $certPassword -Force -AsPlainText  

        # Ensure PnP.PowerShell module is installed
        if (Get-Module -ListAvailable -Name "PnP.PowerShell") {
            Write-Host "PnP.PowerShell already installed"
        } else {
            Install-Module -Name PnP.PowerShell -Scope CurrentUser -AllowClobber -Force
        }

        # Import required modules
        Import-Module PnP.PowerShell        
        Import-Module -Name ".\Scripts\Custom\Add-FileToSharePoint.psm1" -Force 

        # Define the path to the downloaded reports
        $combinedReportsPath = "$(Pipeline.Workspace)/a/CombinedReports"
        Write-Host "##[debug]Combined Reports Path: $combinedReportsPath"

        # Find all *.Report folders recursively
        $reportFolders = Get-ChildItem -Path $combinedReportsPath -Directory -Recurse | Where-Object { $_.Name -like "*.Report" }

        # Get the current timestamp for unique file naming
        $currentTime = [DateTime]::UtcNow.ToString('yyyyMMdd_HHmmss')

        foreach ($folder in $reportFolders) {
            Write-Host "##[debug]Processing folder: $($folder.FullName)"
            
            # Extract metadata from the folder path
            $tempSplit = ($folder.FullName -split "~")
            $workspaceName = $tempSplit[$tempSplit.Length - 4]
            $repositoryId = $tempSplit[$tempSplit.Length - 3]
            $branchName = $tempSplit[$tempSplit.Length - 2]
            $commitId = ($tempSplit[$tempSplit.Length - 1] -split "\\")[0]

            Write-Host "##[debug]Workspace Name: $workspaceName"
            Write-Host "##[debug]Repository ID: $repositoryId"
            Write-Host "##[debug]Branch Name: $branchName"
            Write-Host "##[debug]Commit ID: $commitId"
            
            # Ensure the .platform file exists in the folder
            if (!(Test-Path -LiteralPath "$($folder.FullName)/.platform")) {
                Write-Error "Could not locate .platform file in $($folder.FullName)"
                exit 1
            }

            try {
                # Read metadata from the .platform file
                $platformContent = Get-Content -LiteralPath "$($folder.FullName)/.platform" -Encoding utf8 | ConvertFrom-Json            
                $reportName = $platformContent.metadata.displayName     
                $logicalId = $platformContent.config.logicalId                   
                
                # Define the output path for PBI Inspector results
                $outputFilePath = ".\PBIInspectorTests\$($repositoryId)\$($branchName)\$($logicalId)~$($commitId)~$($currentTime)"
                Write-Host "##[debug]Output file path: $outputFilePath"

                # Run PBIXInspectorCLI to analyze the report
                .\PBI-Inspector\PBIXInspectorCLI -pbipreport $folder.FullName `
                                                 -rules .\Rules\pbi-inspector-custom-rules.json `
                                                 -formats "JSON" `
                                                 -verbose true `
                                                 -output $outputFilePath

                # Retrieve all files generated by PBIXInspectorCLI
                $filesToSaveToGit = Get-ChildItem -Path $outputFilePath -Recurse -File

                foreach ($tempFile in $filesToSaveToGit) {
                  Write-Host "##[debug]Saving $($tempFile.Name) to SharePoint"

                  # Upload the file to SharePoint
                  $result1 = Add-FileToSharePoint -FilePath $tempFile.FullName `
                                   -SiteUrl $siteUrl `
                                   -DocLibPath "$($libraryName)/PBIInspectorTests/$($repositoryId)/$($branchName)/$($logicalId)~$($commitId)~$($currentTime)" `
                                   -TenantId $tenantId `
                                   -ClientId $clientId `
                                   -Base64Cert $certBase64 `
                                   -CertPassword $securePassword `
                                   -CheckInComment "PBI Inspector results saved to $($tempFile.Name)"              

                  # Create a record file with metadata
                  $recordFile = "$($repositoryId)~$($branchName)~$($logicalId)~$($commitId)~$($currentTime).csv"
                  $rows = @()
                  $rows += (
                            '"{0}","{1}","{2}","{3}","{4}","{5}"' -f `
                            "repository_id","branch_name","logical_id","commit_id","artifact_name","artifact_type"
                            )  
                  $rows += (
                            '"{0}","{1}","{2}","{3}","{4}","{5}"' -f `
                            $repositoryId, $branchName, $logicalId, $commitId, $reportName, "Report"
                            )            
                  $csvContent = $rows -join "`n"

                  # Save the record file
                  $csvContent | Out-File -FilePath $recordFile -Encoding utf8

                  # Upload the record file to SharePoint
                  $result2 = Add-FileToSharePoint -FilePath $recordFile `
                                   -SiteUrl $siteUrl `
                                   -DocLibPath "$($libraryName)/Artifacts" `
                                   -TenantId $tenantId `
                                   -ClientId $clientId `
                                   -Base64Cert $certBase64 `
                                   -CertPassword $securePassword `
                                   -CheckInComment "Artifacts results saved to $($recordFile)"              
                  if ($result1 -eq $false -or $result2 -eq $false) {
                    exit 1 # Exit if any upload fails
                  }
                }
            } catch {
                Write-Error "An error occurred: $_"
                throw "An error occurred: $_"
            }
        }
    displayName: 'Run PBI Inspector CLI on each *.Report folder and save test results'
    env:
      CERT_PASSWORD: $(CERT_PASSWORD)
      CERT_BASE64: $(CERT_BASE64)